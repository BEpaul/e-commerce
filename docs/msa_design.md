# MSA (Microservice Architecture) 설계 문서

## 1. 개요

현재 모놀리식 아키텍처로 구성된 E-Commerce 서비스를 MSA로 전환할 경우에 대한 설계를 목표로 한다.

## 2. 도메인 분석 및 서비스 분리

### 2.1 도메인별 서비스 분리

| 서비스 | 책임 | 데이터 | 독립성 | 주요 API |
|--------|------|--------|--------|----------|
| **User Service** | 사용자 정보 관리 | user 테이블 | 높음 | 사용자 조회/생성/수정 |
| **Product Service** | 상품 정보 관리, 재고 관리 | product 테이블 | 높음 | 상품 조회, 재고 차감 |
| **Point Service** | 포인트 잔액 관리, 포인트 이력 관리 | point, point_history 테이블 | 중간 | 포인트 충전/차감, 잔액 조회 |
| **Coupon Service** | 쿠폰 관리, 쿠폰 발급, 쿠폰 사용 | coupon, user_coupon, coupon_outbox_event 테이블 | 중간 | 쿠폰 발급/조회/사용 |
| **Order Service** | 주문 생성, 주문 상태 관리, 주문 조회 | orders, order_product 테이블 | 낮음 | 주문 생성/조회/상태 변경 |
| **Payment Service** | 결제 처리, 결제 상태 관리 | payment 테이블 | 낮음 | 결제 처리/조회/취소 |
| **BestSeller Service** | 베스트셀러 랭킹 관리, 실시간 판매량 집계 | Redis Sorted Set | 높음 | 베스트셀러 조회, 랭킹 업데이트 |

### 2.2 서비스 간 의존성 분석

```
User Service     ←── Order Service
     ↑                    ↑
     └── Point Service ←──┘
     ↑                    ↑
     └── Coupon Service ←──┘
     ↑                    ↑
Product Service ←─────────┘
     ↑                    ↑
     └──────────────────── Payment Service
     ↑                    ↑
BestSeller Service ←──────┘ (이벤트 기반)
```

## 3. 트랜잭션 처리의 한계와 해결방안

### 3.1 분산 트랜잭션의 한계

MSA 도입 시 발생할 수 있는 가장 대표적인 문제!

| 문제 유형 | 구체적 문제 | 한계점 |
|-----------|-------------|--------|
| **주문-결제 트랜잭션** | 주문 생성 → 재고 차감 → 포인트 차감 → 결제 처리의 원자성 보장 | 2PC는 성능 저하와 가용성 문제 발생 |
| **쿠폰 발급 트랜잭션** | 쿠폰 재고 차감 → 사용자 쿠폰 발급의 원자성 보장 | 동시성 제어와 일관성 보장의 복잡성 |
| **데이터 일관성** | 서비스 간 데이터 동기화 및 일관성 유지 | CAP 정리로 인한 일관성 vs 가용성 트레이드오프 |
| **베스트셀러 랭킹 동기화** | 주문/결제 이벤트와 베스트셀러 랭킹 실시간 동기화 | Redis 기반 랭킹 시스템의 장애 시 데이터 복구 |

### 3.2 해결방안

| 패턴 | 적용 분야 | 방식 | 장점 |
|------|-----------|------|------|
| **Saga Pattern** | 주문-결제 프로세스 | Choreography/Orchestration Saga | 성능과 가용성을 유지하면서 분산 트랜잭션 처리 |
| **Event-Driven Architecture** | 서비스 간 느슨한 결합 | Apache Kafka 메시지 브로커 | 서비스 간 독립성 확보, 확장성 향상 |
| **Outbox Pattern** | 쿠폰 발급, 주문 생성 | 로컬 트랜잭션 내 이벤트 저장 후 별도 프로세서 처리 | 이벤트 발행의 안정성과 일관성 보장 |
| **CQRS** | 읽기/쓰기 모델 분리 | 명령과 조회를 위한 별도 모델과 저장소 | 성능 최적화, 확장성 향상 |
| **Circuit Breaker** | 서비스 간 호출 안정성 | 서비스 장애 시 대체 로직 실행 | 장애 전파 방지, 시스템 안정성 향상 |
| **Event-Driven Ranking** | 베스트셀러 랭킹 실시간 업데이트 | 주문 완료 이벤트 수신 시 Redis Sorted Set 업데이트 | 실시간 랭킹 반영, 높은 성능과 확장성 |

## 4. 데이터 일관성 보장 전략

| 전략 | 적용 분야 | 방식 | 장점 |
|------|-----------|------|------|
| **Eventual Consistency** | 전체 시스템 | 강한 일관성 대신 최종 일관성 허용 | 성능과 가용성 향상 |
| **Compensation Pattern** | 주문 취소, 결제 실패 | 실패한 작업에 대한 보상 트랜잭션 실행 | 분산 환경에서의 데이터 일관성 보장 |
| **Distributed Lock** | 쿠폰 발급, 재고 차감 | Redis 기반 분산 락 활용 | 동시성 문제 해결 |
| **Redis-Based Ranking** | 베스트셀러 랭킹 관리 | Redis Sorted Set을 활용한 실시간 랭킹 계산 | O(log N) 시간 복잡도, 실시간 성능 |

## 5. 서비스 간 통신 방식

| 통신 방식 | 적용 대상 | 장점 | 단점 |
|-----------|-----------|------|------|
| **동기 통신 (REST API)** | 실시간 응답이 필요한 API, 사용자 인증 | 간단한 구현, 즉시 응답 | 서비스 간 강한 결합 |
| **비동기 통신 (메시지 큐)** | 이벤트 기반 처리, 배치 작업 | 확장성, 장애 격리 | 복잡한 구현, 디버깅 어려움 |
| **이벤트 기반 통신** | 베스트셀러 랭킹 업데이트, 주문 완료 알림 | 느슨한 결합, 실시간 반응 | 이벤트 순서 보장 어려움 |
| **API Gateway** | 중앙화된 라우팅, 인증/인가 | 중앙화된 관리, 보안 강화 | 단일 장애점 위험 |

## 6. 모니터링 및 관찰성

| 영역 | 도구 | 목적 | 주요 기능 |
|------|------|------|-----------|
| **분산 추적** | Jaeger/Zipkin | 서비스 간 호출 추적 | 성능 병목 지점 식별, 장애 원인 분석 |
| **중앙화된 로깅** | ELK Stack | 통합 로그 관리 및 분석 | 로그 수집, 검색, 시각화 |
| **메트릭 수집** | Prometheus + Grafana | 성능 모니터링, 알림 설정 | 서비스별 성능 메트릭, 비즈니스 메트릭 |

## 7. 배포 및 운영 전략

| 영역 | 기술/도구 | 목적 | 장점 |
|------|-----------|------|------|
| **컨테이너화** | Docker + Kubernetes | 독립적 배포, 자동 스케일링 | 서비스 디스커버리, 확장성 |
| **CI/CD 파이프라인** | GitHub Actions | 자동화된 빌드/테스트/배포 | 서비스별 독립적 배포 |
| **데이터베이스 분리** | 서비스별 독립 DB | 스키마 변경 독립성 | 장애 격리 |
| **Redis 인프라** | Redis Cluster/Sentinel | 고가용성, 확장성 | 장애 복구 |

## 8. 결론

### 8.1 MSA 전환의 장점

| 장점 | 설명 | 비즈니스 가치            |
|------|------|--------------------|
| **독립적 배포** | 서비스별 독립적인 개발/배포 가능 | 빠른 기능 출시, 팀 생산성 향상 |
| **기술 다양성** | 서비스별 최적 기술 스택 선택 가능 | 기술 혁신, 비용 최적화      |
| **확장성** | 서비스별 독립적 스케일링 | 트래픽 대응, 리소스 효율성    |
| **장애 격리** | 한 서비스의 장애가 전체 시스템에 미치는 영향 최소화 | 시스템 안정성, 사용자 경험 향상 |

### 8.2 고려사항

| 고려사항 | 설명 | 대응 방안 |
|----------|------|-----------|
| **복잡성 증가** | 분산 시스템의 복잡성 | 강력한 모니터링, 자동화 도구 |
| **성능 오버헤드** | 네트워크 통신 오버헤드 | 캐싱 전략, 비동기 통신 |
| **데이터 일관성** | 분산 환경에서의 데이터 일관성 관리 | Eventual Consistency, 보상 패턴 |
| **운영 복잡성** | 모니터링, 로깅, 배포 복잡성 증가 | DevOps 문화, 자동화 파이프라인 |
